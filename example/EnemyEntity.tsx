/*
This file was generated by https://github.com/pmndrs/gltfjsx and then
customized manually. It uses drei's new useAnimations hook which extracts
all actions and sets up a THREE.AnimationMixer for it so that you don't have to.
All of the assets actions, action-names and clips are available in its output. 
*/

import * as THREE from "three";
import React, { useEffect, useState, useMemo, useRef } from "react";
import {
  useGLTF,
  useTexture,
  useCursor,
  useAnimations,
} from "@react-three/drei";
import { useGame } from "../src/stores/useGame";
import { useGraph, useFrame } from "@react-three/fiber";
import { a, useSpring } from "@react-spring/three";
import { SkeletonUtils } from "three-stdlib";
import { RigidBody, CapsuleCollider } from "@react-three/rapier";

const MAX_LINVEL = 2;
const ROTATION_THRESHOLD = Math.PI;
const IMPULSE_FACTOR = 50.0;
const ATTACK_THRESHOLD = 1.0;

function verifyLinvel(body) {
  const linvel = body?.current?.linvel();
  const linvelMagnitude = Math.sqrt(linvel?.x ** 2 + linvel?.z ** 2);
  return linvelMagnitude < MAX_LINVEL;
}

function getRotation(impulse, delta, scene) {
  const targetAngle = Math.atan2(impulse.x, impulse.z);
  const currentAngle = scene.rotation.y;
  const newAngle = THREE.MathUtils.lerp(
    currentAngle,
    targetAngle,
    0.1 * delta * 100
  );
  const angleDifference = Math.abs(newAngle - targetAngle);
  return angleDifference <= ROTATION_THRESHOLD ? newAngle : targetAngle;
}

function getImpulse(delta, inputDirection) {
  const impulseStrength = IMPULSE_FACTOR * delta;
  return {
    x: inputDirection.x * impulseStrength,
    y: 0,
    z: inputDirection.z * impulseStrength,
  };
}

export default function Model({ position, ...props }) {
  // For the rigidbody component
  const body = useRef<RigidBody>();
  // Fetch model and a separate texture
  const { scene, animations } = useGLTF("/stacy.glb");
  //   const texture = useTexture("/stacy.jpg");

  // Skinned meshes cannot be re-used in threejs without cloning them
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);
  // useGraph creates two flat object collections for nodes and materials
  const { nodes } = useGraph(clone);

  // Extract animation actions
  const { ref, actions, names } = useAnimations(animations);
  const getCharacterPosition = useGame((state) => state.getCurPosition);

  // Hover and animation-index states
  //   const [hovered, setHovered] = useState(false);
  const [index, setIndex] = useState(1); // Set to idle
  // Animate the selection halo
  //   const { color, scale } = useSpring({
  //     scale: hovered ? [1.15, 1.15, 1] : [1, 1, 1],
  //     color: hovered ? "hotpink" : "aquamarine",
  //   });
  // Change cursor on hover-state
  //   useCursor(hovered);

  useEffect(() => {
    actions[names[index]]?.reset().fadeIn(0.5).play();
    return () => {
      actions[names[index]]?.fadeOut(0.5);
      // Explicitly return void
    };
  }, [index, actions, names]);

  useFrame((state, delta) => {
    const characterPosition = getCharacterPosition();
    if (!body.current || !characterPosition) return;
    const direction = new THREE.Vector3()
      .subVectors(characterPosition, body.current.translation())
      .normalize();
    const bodyTranslation = new THREE.Vector3(
      body.current.translation().x,
      body.current.translation().y,
      body.current.translation().z
    );
    if (bodyTranslation.distanceTo(characterPosition) > ATTACK_THRESHOLD) {
      const impulse = getImpulse(delta, direction);
      if (ref.current) {
        ref.current.rotation.y = getRotation(impulse, delta, scene);
      }
      if (verifyLinvel(body)) body.current.applyImpulse(impulse);
      // Walk
      setIndex(2);
    } else {
      // Attack
      setIndex(0);
    }
  });

  return (
    <RigidBody
      ref={body}
      canSleep={false}
      mass={1.0}
      position={position}
      linearDamping={1}
      angularDamping={0.5}
      enabledRotations={[false, false, false]}
    >
      <CapsuleCollider args={[0.4, 0.4]} position={[0, 0.8, 0]} />
      <group ref={ref} dispose={null}>
        <group rotation={[Math.PI / 2, 0, 0]} scale={[0.01, 0.01, 0.01]}>
          <primitive object={nodes.mixamorigHips} />
          <skinnedMesh
            castShadow
            receiveShadow
            geometry={nodes.stacy.geometry}
            skeleton={nodes.stacy.skeleton}
            rotation={[-Math.PI / 2, 0, 0]}
            scale={[100, 100, 100]}
          >
            {/* <meshStandardMaterial map-flipY={false} skinning /> */}
          </skinnedMesh>
        </group>
        {/* <a.mesh receiveShadow position={[0, 1, -1]} scale={scale}>
        <circleBufferGeometry args={[0.6, 64]} />
        <a.meshStandardMaterial color={color} />
      </a.mesh> */}
      </group>
    </RigidBody>
  );
}
