/*
This file was generated by https://github.com/pmndrs/gltfjsx and then
customized manually. It uses drei's new useAnimations hook which extracts
all actions and sets up a THREE.AnimationMixer for it so that you don't have to.
All of the assets actions, action-names and clips are available in its output. 
*/

import * as THREE from "three";
import React, { useEffect, useState, useMemo, useRef } from "react";
import { useGLTF, useTexture, useAnimations } from "@react-three/drei";
import { useGame } from "../src/stores/useGame";
import { useGraph, useFrame } from "@react-three/fiber";
import { SkeletonUtils } from "three-stdlib";
import { RigidBody, CapsuleCollider } from "@react-three/rapier";

const MAX_LINVEL = 2;
const ROTATION_THRESHOLD = Math.PI;
const IMPULSE_FACTOR = 50.0;
const ATTACK_THRESHOLD = 1.0;

function verifyLinvel(body) {
  const linvel = body?.current?.linvel();
  const linvelMagnitude = Math.sqrt(linvel?.x ** 2 + linvel?.z ** 2);
  return linvelMagnitude < MAX_LINVEL;
}

function getRotation(impulse, delta, ref) {
  const targetAngle = Math.atan2(impulse.x, impulse.z);
  const currentAngle = ref.rotation.y;
  const newAngle = THREE.MathUtils.lerp(
    currentAngle,
    targetAngle,
    0.1 * delta * 100
  );
  const angleDifference = Math.abs(newAngle - targetAngle);
  return angleDifference <= ROTATION_THRESHOLD ? newAngle : targetAngle;
}

function getImpulse(delta, inputDirection) {
  const impulseStrength = IMPULSE_FACTOR * delta;
  return {
    x: inputDirection.x * impulseStrength,
    y: 0,
    z: inputDirection.z * impulseStrength,
  };
}

export default function Model({ position, ...props }) {
  // For the rigidbody component
  const body = useRef<RigidBody>();
  // Fetch model and a separate texture
  const { scene, animations, materials } = useGLTF("/sb_restart.glb");
  const texture = useTexture("/sponge_512.png");
  //   const texture = useTexture("/stacy.jpg");

  // Skinned meshes cannot be re-used in threejs without cloning them
  const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);
  // useGraph creates two flat object collections for nodes and materials
  const { nodes } = useGraph(clone);

  // Extract animation actions
  const { ref, actions, names } = useAnimations(animations);
  const getCharacterPosition = useGame((state) => state.getCurPosition);

  // Hover and animation-index states
  const [index, setIndex] = useState(1);

  useEffect(() => {
    actions[names[index]]?.reset().fadeIn(0.5).play();
    return () => {
      actions[names[index]]?.fadeOut(0.5);
      // Explicitly return void
    };
  }, [index, actions, names]);

  useFrame((state, delta) => {
    const characterPosition = getCharacterPosition();
    if (!body.current || !characterPosition) return;
    const direction = new THREE.Vector3()
      .subVectors(characterPosition, body.current.translation())
      .normalize();
    const bodyTranslation = new THREE.Vector3(
      body.current.translation().x,
      body.current.translation().y,
      body.current.translation().z
    );
    if (bodyTranslation.distanceTo(characterPosition) > ATTACK_THRESHOLD) {
      const impulse = getImpulse(delta, direction);
      if (ref.current) {
        console.log(getRotation(impulse, delta, ref.current));
        ref.current.rotation.y = getRotation(impulse, delta, ref.current);
      }
      if (verifyLinvel(body)) body.current.applyImpulse(impulse);
      // Walk
      setIndex(1);
    } else {
      // Attack
      setIndex(0);
    }
  });

  return (
    <RigidBody
      ref={body}
      colliders={false}
      canSleep={false}
      mass={1.0}
      position={position}
      linearDamping={1}
      angularDamping={0.5}
      enabledRotations={[false, false, false]}
    >
      <CapsuleCollider args={[0.4, 0.4]} position={[0, 0.8, 0]} />
      <group ref={ref} dispose={null}>
        <group name="Scene">
          <group name="Armature" position={[0, 0.316, 0]} scale={0.651}>
            <group name="Sponge">
              <skinnedMesh
                name="Cube003"
                geometry={nodes.Cube003.geometry}
                skeleton={nodes.Cube003.skeleton}
              >
                <meshStandardMaterial map={texture} map-flipY={false} />
              </skinnedMesh>
              <skinnedMesh
                name="Cube003_1"
                geometry={nodes.Cube003_1.geometry}
                material={materials.Outline}
                skeleton={nodes.Cube003_1.skeleton}
              />
            </group>
            <primitive object={nodes.Main} />
            <primitive object={nodes.ShoulderL} />
            <primitive object={nodes.ShoulderR} />
          </group>
        </group>
      </group>
    </RigidBody>
  );
}
